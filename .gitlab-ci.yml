stages:
  - conform
  - lint
  - test
  - build
  - post-build
  - pages

include:
  template: Dependency-Scanning.gitlab-ci.yml

variables:
  ARCH_DEFAULT: "amd64"
  ARCHES: amd64 arm64 arm
  APP_BUILD_VERSION: 0.0.0
  APP_BUILD_MODE: development
  POSTGRES_DB: flattrack
  POSTGRES_USER: flattrack
  POSTGRES_PASSWORD: flattrack
  MINIO_ROOT_USER: minioadmin
  MINIO_ROOT_PASSWORD: minioadmin
  IMAGE_GOLANG_ALPINE: docker.io/golang:1.21.3-alpine3.18@sha256:926f7f7e1ab8509b4e91d5ec6d5916ebb45155b0c8920291ba9f361d65385806
  EXTRA_REGISTRIES: docker.io
  IMAGE_NODE_ALPINE: docker.io/node:20-alpine3.17@sha256:8f60bc701ea888b5daa02f38ddd0c3c71ce9b65c30d481418b713ccd22bd4e32
  IMAGE_ALPINE: docker.io/alpine:3.18@sha256:eece025e432126ce23f223450a0326fbebde39cdf496a85d8c016293fc851978
  IMAGE_PYTHON: docker.io/python:3.8-buster@sha256:04c3f641c2254c229fd2f704c5199ff4bea57d26c1c29008ae3a4afddde98709
  IMAGE_GOLANGCI_LINT: docker.io/golangci/golangci-lint:v1.53.3@sha256:1e0e2867b387bf68762427db499a963e43582b06819992db205fc31daa75ceea
  VERSION_KO: 0.14.1
  VERSION_COSIGN: v2.2.0
  COSIGN_YES: "true"

.container-registry-login-ko: &container-registry-login-ko |
  ko login "${CI_REGISTRY}" -u "${CI_REGISTRY_USER}" -p "${CI_REGISTRY_PASSWORD}"
  ko login "docker.io" -u "${DOCKERHUB_USERNAME}" -p "${DOCKERHUB_PASSWORD}"

.container-registry-login-crane: &container-registry-login-crane |
  mkdir -p $(getent passwd $(id -u) | cut -d ':' -f6)/.docker
  cat << EOF > $(getent passwd $(id -u) | cut -d ':' -f6)/.docker/config.json
  {
    "auths": {
      "$CI_REGISTRY": {
        "username": "$CI_REGISTRY_USER",
        "password": "$CI_REGISTRY_PASSWORD"
      },
      "https://index.docker.io/v1/": {
        "auth": "$DOCKERHUB_AUTH"
      }
    }
  }
  EOF

.image-build-taggable-name: &image-build-taggable-name |
  set -x
  echo "Commit made on '${CI_COMMIT_TIMESTAMP}'"
  export APP_BUILD_HASH="$CI_COMMIT_SHORT_SHA"
  export APP_BUILD_DATE=$(date --date="$(echo ${CI_COMMIT_TIMESTAMP//[T]/ } | sed 's/+.*//g')" '+%Y.%m.%d.%H%M')
  if [[ -z "$CI_COMMIT_TAG" ]]; then
    PRINTABLE_COMMIT_HASH="-$APP_BUILD_HASH"
  fi
  if [[ ! "$CI_COMMIT_BRANCH" = "$CI_DEFAULT_BRANCH" ]] && [[ -z "$CI_COMMIT_TAG" ]]; then
    BRANCH_NAME="-$CI_COMMIT_BRANCH"
  fi
  PROJECT_PATH=$(echo $CI_PROJECT_PATH | tr '[:upper:]' '[:lower:]')

.image-pre-build-release-version: &image-pre-build-release-version |
  export APP_BUILD_VERSION=0.0.0
  export APP_BUILD_MODE=production
  export IMAGE_DESTINATIONS="latest$BRANCH_NAME"
  if [[ ! -z "$CI_COMMIT_TAG" ]]; then
    export APP_BUILD_VERSION="$CI_COMMIT_TAG"
    export IMAGE_DESTINATIONS="$APP_BUILD_VERSION"
  fi
  export VITE_APP_AppBuildVersion="$APP_BUILD_VERSION"
  export VITE_APP_AppBuildDate="$APP_BUILD_DATE"
  export VITE_APP_AppBuildHash="$APP_BUILD_HASH"
  export VITE_APP_AppBuildMode="$APP_BUILD_MODE"

.zip-prepare: &zip-prepare |
  export RELEASE_FOLDER_NAME="flattrack$BRANCH_NAME$PRINTABLE_COMMIT_HASH"
  mkdir -p $RELEASE_FOLDER_NAME

.setup-cosign: &setup-cosign |
  curl -sSL https://github.com/sigstore/cosign/releases/download/$VERSION_COSIGN/cosign-linux-amd64  -o /usr/local/bin/cosign
  chmod +x /usr/local/bin/cosign

.setup-ko: &setup-ko |
  curl -sSL https://github.com/ko-build/ko/releases/download/v${VERSION_KO}/ko_${VERSION_KO}_Linux_x86_64.tar.gz -o /tmp/ko.tar.gz
  < /tmp/ko.tar.gz tar -C /usr/local/bin -xvf - ko

build-backend-smoketest:
  stage: build
  image: $IMAGE_GOLANG_ALPINE
  script:
    - go build -o /dev/null .

build-container:
  stage: build
  image:
    name: $IMAGE_GOLANG_ALPINE
    entrypoint: [""]
  retry: 2
  id_tokens:
    SIGSTORE_ID_TOKEN:
      aud: "sigstore"
  variables:
    KO_DOCKER_REPO: "$CI_REGISTRY_IMAGE"
  before_script:
    - apk add --no-cache curl
    - *setup-ko
    - *setup-cosign
    - *container-registry-login-ko
    - *image-build-taggable-name
    - *image-pre-build-release-version
  script:
    - |
      mkdir -p ./kodata/{web/dist,}
      cp -r ./web/dist ./kodata/web
    - |
      IMAGE="$(ko publish \
      --jobs 100 \
      --bare \
      --tags "${IMAGE_DESTINATIONS}" \
      .)"
    - cosign sign --recursive -y "$IMAGE"
    - cosign download sbom $IMAGE > /tmp/sbom-spdx.json
    - cosign attest -y --recursive --predicate /tmp/sbom-spdx.json $IMAGE
    # TODO use common script - ${CI_PROJECT_DIR}/hack/build-container.sh production
  needs:
    - build-frontend

copy-container-image-to-dockerhub:
  stage: post-build
  only:
    - main
  image: $IMAGE_GOLANG_ALPINE
  before_script:
    - go install github.com/google/go-containerregistry/cmd/crane@latest
    - *container-registry-login-crane
    - *image-build-taggable-name
    - *image-pre-build-release-version
  script:
    - |
      [ -z "${EXTRA_REGISTRIES}" ] && exit 0
      for TAG in $(echo ${IMAGE_DESTINATIONS:-} | tr ',' ' '); do
        for REG in ${EXTRA_REGISTRIES}; do
          crane copy "${CI_REGISTRY}/${PROJECT_PATH}:${TAG}" "${REG}/${PROJECT_PATH}:${TAG}"
        done
      done

build-helm-chart:
  stage: build
  image: $IMAGE_ALPINE
  variables:
    HELM_LINK: https://get.helm.sh/helm-v3.4.0-linux-amd64.tar.gz
    HELM_HASH: 270acb0f085b72ec28aee894c7443739271758010323d72ced0e92cd2c96ffdb
  allow_failure: true
  before_script:
    - *image-build-taggable-name
    - apk add curl
    - curl -L -o helm.tar.gz $HELM_LINK
    - |
        if [ ! $(sha256sum helm.tar.gz) = $HELM_HASH ]; then
          exit 1
        fi
    - cat helm.tar.gz | tar --directory /usr/local/bin --extract -xz --strip-components 1 linux-amd64/helm
  script:
    - helm package deployments/flattrack --destination .helm-root/helm/
    - helm repo index --url "https://${CI_PROJECT_NAMESPACE}.gitlab.io/${CI_PROJECT_NAME}" .helm-root/
  artifacts:
    paths:
      - .helm-root
  only:
    - main

build-frontend:
  stage: build
  retry: 2
  image: $IMAGE_NODE_ALPINE
  before_script:
    - *image-build-taggable-name
    - *image-pre-build-release-version
    - *zip-prepare
    - cd web
    - apk add --no-cache make g++
    - npm i
  script:
    - npm run build
  after_script:
    - |
      if [[ ! -z "$CI_COMMIT_TAG" ]]; then
        mkdir -p "${RELEASE_FOLDER_NAME}/dist"
        cd web/dist
        cp -R . "${RELEASE_FOLDER_NAME}/dist"
      fi
  artifacts:
    expire_in: 1 day
    paths:
      - web/dist
      - flattrack*/

build-zip-backend:
  stage: build
  retry: 2
  image: $IMAGE_GOLANG_ALPINE
  before_script:
    - *image-build-taggable-name
    - *image-pre-build-release-version
    - *zip-prepare
  script:
    - |
      for ARCH in $ARCHES; do
        echo "Building backend for $ARCH";
        PRINTABLE_ARCH="-$ARCH"
        if [ $ARCH = $ARCH_DEFAULT ]; then
          PRINTABLE_ARCH=
        fi
        CGO_ENABLED=0 GOOS=linux GOARCH="$ARCH" go build \
          -a \
          -installsuffix cgo \
          -ldflags "-extldflags '-static' -s -w \
          -X gitlab.com/flattrack/flattrack/pkg/common.AppBuildVersion=$APP_BUILD_VERSION \
          -X gitlab.com/flattrack/flattrack/pkg/common.AppBuildHash=$APP_BUILD_HASH \
          -X gitlab.com/flattrack/flattrack/pkg/common.AppBuildDate=$APP_BUILD_DATE \
          -X gitlab.com/flattrack/flattrack/pkg/common.AppBuildMode=$APP_BUILD_MODE" \
          -o $RELEASE_FOLDER_NAME/flattrack$PRINTABLE_ARCH \
          main.go
      done
  only:
    - tags
    - main
  artifacts:
    expire_in: 1 day
    paths:
      - flattrack*

build-zip-copy-extras:
  stage: build
  retry: 2
  image: $IMAGE_ALPINE
  before_script:
    - *image-build-taggable-name
    - *image-pre-build-release-version
    - *zip-prepare
  script:
    - cp -r kodata/migrations $RELEASE_FOLDER_NAME/migrations
    - cp -r templates $RELEASE_FOLDER_NAME/templates
    - cp example.env $RELEASE_FOLDER_NAME
  only:
    - tags
    - main
  artifacts:
    expire_in: 1 day
    paths:
      - flattrack*

build-zip:
  stage: post-build
  retry: 2
  image: $IMAGE_ALPINE
  needs:
    - build-zip-backend
    - build-zip-copy-extras
  before_script:
    - *image-build-taggable-name
    - *image-pre-build-release-version
    - *zip-prepare
  script:
    - tar cvf $RELEASE_FOLDER_NAME.tar.gz $RELEASE_FOLDER_NAME
  only:
    - tags
    - main
  artifacts:
    paths:
      - flattrack*.tar.gz

test_backend_e2e:
  stage: test
  image: $IMAGE_GOLANG_ALPINE
  variables:
    POSTGRES_DB: flattrack
    POSTGRES_USER: flattrack
    POSTGRES_PASSWORD: flattrack
    POSTGRES_HOST_AUTH_METHOD: trust
    APP_DB_HOST: postgres
    APP_DB_USERNAME: flattrack
    APP_DB_PASSWORD: flattrack
    APP_DB_DATABASE: flattrack
    APP_MINIO_HOST: minio:9000
    APP_MINIO_ACCESS_KEY: minioadmin
    APP_MINIO_SECRET_KEY: minioadmin
    APP_MINIO_BUCKET: flattrack
    APP_MINIO_USE_SSL: "false"
    CGO_ENABLED: "0"
  services:
    - name: postgres:15.3-alpine
      alias: postgres
    - name: minio/minio:RELEASE.2023-06-29T05-12-28Z
      alias: minio
      command:
        - server
        - /data
  before_script:
    - apk add --no-cache git gcc curl
    - go install github.com/onsi/ginkgo/ginkgo@v1.16.5
    - go build -o ./bin/flattrack main.go
    - ./bin/flattrack &
    - until curl -s http://localhost:8080; do echo "Waiting for API"; sleep 1s; done
  script:
    - ginkgo -r --randomizeAllSpecs --randomizeSuites --failOnPending --cover --trace --progress test/backend/e2e
    - pkill flattrack || true

spell_check:
  stage: lint
  image: $IMAGE_GOLANG_ALPINE
  allow_failure: true
  before_script:
    - go install github.com/client9/misspell/cmd/misspell@latest
  script:
    - misspell -error pkg cmd docs kodata/migrations pubic template k8s-manifests README*

govet:
  stage: lint
  image: $IMAGE_GOLANG_ALPINE
  script:
    - go vet -v ./...

gofmt:
  stage: lint
  image: $IMAGE_GOLANG_ALPINE
  script:
    - find . -name "*.go" | grep -E -v vendor | xargs gofmt -s -l -d -w -s

goimports:
  stage: lint
  image: $IMAGE_GOLANG_ALPINE
  before_script:
    - apk add --no-cache git
    - go install golang.org/x/tools/cmd/goimports@latest
  script:
    - find . -type f -name '*.go' -not -path './vendor/*' | xargs -I{} goimports -w {}
    - |
      if git diff --name-only --diff-filter=ACMRT | grep -E '(.*).go$'; then
        echo "error: changes detected, run 'find . -type f -name '*.go' -not -path './vendor/*' | xargs -I{} goimports -w {}'"
        exit 1
      fi

golangci-lint:
  stage: lint
  image:
    name: $IMAGE_GOLANGCI_LINT
    entrypoint: [""]
  script:
    - golangci-lint run

govulncheck:
  stage: lint
  image: $IMAGE_GOLANG_ALPINE
  before_script:
    - go install golang.org/x/vuln/cmd/govulncheck@latest
  script:
    - govulncheck ./...

lint_frontend:
  stage: lint
  image: $IMAGE_NODE_ALPINE
  allow_failure: true
  before_script:
    - cd web
    - apk add --no-cache make g++
    - npm i
  script:
    - npm run lint

lint_backend:
  stage: lint
  image: $IMAGE_GOLANG_ALPINE
  allow_failure: true
  before_script:
    - apk add git gcc
    - go install golang.org/x/lint/golint@latest
  script:
    - echo -e "GOLINT\n"
    - golint -set_exit_status ./...
    - echo -e "GOFMT\n"
    - gofmt -d .

lint_helm_chart:
  stage: lint
  image: $IMAGE_ALPINE
  variables:
    HELM_LINK: https://get.helm.sh/helm-v3.4.0-linux-amd64.tar.gz
    HELM_HASH: 270acb0f085b72ec28aee894c7443739271758010323d72ced0e92cd2c96ffdb
  allow_failure: true
  before_script:
    - apk add curl
    - curl -L -o helm.tar.gz $HELM_LINK
    - |
        if [ ! $(sha256sum helm.tar.gz) = $HELM_HASH ]; then
          exit 1
        fi
    - cat helm.tar.gz | tar --directory /usr/local/bin --extract -xz --strip-components 1 linux-amd64/helm
  script:
    - helm lint deployments/flattrack

pages:
  image: $IMAGE_PYTHON
  stage: pages
  before_script:
    - pip install mkdocs-material material-plausible-plugin
  script:
    - mkdocs build
    - mv site public
  artifacts:
    paths:
      - public
  only:
    - main

pages-smoketest:
  image: $IMAGE_PYTHON
  stage: lint
  before_script:
    - pip install mkdocs-material material-plausible-plugin
  script:
    - mkdocs build
  except:
    - main

conform:
  stage: conform
  only:
    - merge_requests
  image:
    name: docker.io/library/alpine:3.18
    entrypoint: [""]
  before_script:
    - apk add --no-cache curl git
    - git fetch origin
    - |
      curl -sSL \
        -o /usr/local/bin/conform \
        https://github.com/siderolabs/conform/releases/download/v0.1.0-alpha.27/conform-linux-amd64
    - chmod +x /usr/local/bin/conform
  script:
    - conform enforce --commit-ref=refs/remotes/origin/main
